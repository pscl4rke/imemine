#!/usr/bin/python2
#======================================================================#
# PRE-MP EMAIL CLEANSER                     (c) 2014,2018 P. S. Clarke #
#======================================================================#


# `mp` is a program that reads an email from STDIN and writes a
# postscript rendering of it to STDOUT.
#
# It is reasonable, but has many weaknesses, mostly because it
# predates MIME encoding, attachments, HTML parts etc.
#
# This script sits in the pipeline before mp, and cleans it into
# a state that mp can use.  E.g. scrubbing non plaintext parts.


import email, email.header
import quopri
import sys


# Want to do:   handle non-ascii character encodings in content
# Want to do:   stop using one line per address in headers
# Maybe to do:  add local time
# Maybe to do:  render html into text instead of bundled text/plain
# Maybe to do:  hash the contents of attachments to find them again


def cleanup(header):
    """Fix the RFC 2047 Mime-Encoded-Word stuff in headers."""
    parts = email.header.decode_header(header)
    full = " ".join(txt.decode('ascii' if (enc is None) else enc)
                       .encode('ascii', 'replace')
                    for (txt, enc) in parts)
    full = " ".join(word for word in full.split())
    return full.replace(", ", ",\n ")


class PreMP:

    def writeln(self, line):
        sys.stdout.write("%s\n" % line)

    def main(self):
        text = sys.stdin.read()
        if len(text) == 0:
            raise Exception("Read message of zero length")
        msg = email.message_from_string(text)
        self.writeln("From: %s" % cleanup(msg['From']))
        self.writeln("To: %s" % cleanup(msg['To']))
        if 'Cc' in msg:
            self.writeln("Cc: %s" % cleanup(msg['Cc']))
        self.writeln("Subject: %s" % cleanup(msg['Subject']))
        self.writeln("Date: %s" % msg['Date'])
        self.writeln("")
        for part in msg.walk():
            if part.get_content_maintype() == 'multipart':
                continue
            if part.get_content_type() == 'text/plain':
                encoding = "utf8"  # really should parse Content-Type properly
                if "Windows-1252" in part.get("Content-Type"):
                    encoding = "cp1252"
                payload = part.get_payload()
                if part.get("Content-Transfer-Encoding", "") == "quoted-printable":
                    payloadu = quopri.decodestring(payload).decode(encoding)
                elif part.get("Content-Transfer-Encoding", "") == "base64":
                    payloadu = payload.decode('base64').decode(encoding)
                else:
                    payloadu = payload.decode(encoding)
                self.writeln(payloadu.encode('ascii', 'replace'))
            else:
                mtype = part.get_content_type()
                size = len(part.get_payload())
                self.writeln("")
                self.writeln("| A %r part was scrubbed (%i bytes)" % (mtype, size))
                for key, value in part.items():
                    self.writeln("|     %s: %s" % (key, value))
                self.writeln("")


if __name__ == '__main__':
    PreMP().main()
