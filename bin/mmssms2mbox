#!/usr/bin/python3


import argparse
import datetime
import email.message
import os
import sqlite3
import time


ME = "me@example.com"


def normalise(number):
    if number.startswith("+44"):
        return "0" + number[3:]
    return number


class SmsDb:

    def __init__(self, filepath):
        if not os.path.exists(filepath):
            raise Exception("Missing file %r" % filepath)
        self._connection = sqlite3.connect(filepath)
        self._contacts = {}

    def load_contacts_from(self, contact_path):
        with open(contact_path) as infile:
            for line in infile:
                name, number = line.rsplit(None, 1)
                self._contacts[normalise(number.strip())] = name.strip()

    def get_messages(self):
        cursor = self._connection.cursor()
        cursor.execute("""
            SELECT _id, thread_id, type, address, date, date_sent, body
            FROM sms
        """)
        return [Message(self._contacts, a, b, c, d, e, f, g)
                for (a, b, c, d, e, f, g)
                in cursor.fetchall()]


class Message:

    def __init__(self, contacts, message_id, thread_id, inorout, sender, ts_rcvd, ts_sent, body):
        self._contacts = contacts
        self._message_id = message_id
        self._thread_id = thread_id
        self._inorout = inorout
        self._sender = sender
        self._ts_rcvd = ts_rcvd / 1000
        self._ts_sent = ts_sent / 1000
        self._body = body

    def is_inbound(self):
        return self._inorout == 1

    def is_outbout(self):
        return self._inorout == 2

    def guess_subject(self):
        body = self._body.replace("\n", " ").replace("\r", " ").strip(" ")
        if len(body) < 63:
            return body
        else:
            return "%s..." % body[:60].rstrip(" ")

    def sender_address(self):
        address = "%s@example.com" % self._sender
        if normalise(self._sender) in self._contacts:
            return "%s <%s>" % (self._contacts[normalise(self._sender)], address)
        else:
            return address

    def timestamp(self):
        # This can't handle sent messages: FIXME
        return self._ts_rcvd if (self._ts_sent == 0) else self._ts_sent

    def formatted_date(self):
        return time.ctime(self.timestamp()) # use local time zone

    def formatted_date_at_my_end(self):
        timestamp = 0 if (self._ts_sent == 0) else self._ts_rcvd
        return time.ctime(timestamp) # use local time zone

    def month_code(self):
        dt = datetime.datetime.fromtimestamp(self.timestamp())
        return dt.strftime("%Y%m")

    def as_email(self):
        eml = email.message.Message()
        eml.set_unixfrom("From dummy %s" % self.formatted_date())
        eml['Date'] = self.formatted_date()
        if self.is_inbound():
            eml['Rcvd'] = self.formatted_date_at_my_end()
            eml['From'] = self.sender_address()
            eml['To'] = ME
        else:
            eml['To'] = self.sender_address()
            eml['From'] = ME
        eml['Subject'] = self.guess_subject()
        eml['In-Reply-To'] = "<%06i.%s@example.com>" % (self._thread_id, self.month_code())
        eml['Status'] = "RO" # read and old
        # From Python 3.6 set_payload is legacy and set_content should be used...
        eml.set_payload(self._body.encode("ascii", "replace")) # FIXME
        #eml.set_payload(self._body.encode("ascii", "backslashreplace")) # FIXME
        return eml


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("db", help="The path to the Android database file")
    parser.add_argument("-c", "--contacts", action="append", default=[],
                        help="The path to a contacts list")
    options = parser.parse_args()
    db = SmsDb(options.db)
    for contact_file in options.contacts:
        db.load_contacts_from(contact_file)
    messages = db.get_messages()
    for message in messages:
        eml = message.as_email()
        print(eml.as_string(unixfrom=True, maxheaderlen=77))


if __name__ == '__main__':
    main()
