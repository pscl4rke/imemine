#!/usr/bin/python3


import os
import sys
import time

import mutagen, mutagen.id3


# improve genre checking
# check title-case tracks
# check artist names first-last
# check id3v1 data matches id3v2 data
# check filename matches id3v2 data
# check album art of good quality
# check classical music for Composer etc
# perhaps check the year


def is_a_recent_file(path):
    one_year = 60 * 60 * 24 * 365
    threshold = time.time() - one_year  # increase as necessary
    mtime = os.stat(path).st_mtime
    return (mtime > threshold)


def check(path_to_check):
    if os.path.isdir(path_to_check):
        yield from check_album_dir(path_to_check)
    if path_to_check.endswith(".mp3"):
        yield from check_mp3(path_to_check)


def check_album_dir(path_to_check):
    files = os.listdir(path_to_check)
    files.sort()
    if "Folder.jpg" not in files:
        yield path_to_check, "Missing Folder.jpg"
    for filename in files:
        path = os.path.join(path_to_check, filename)
        if filename.endswith(".mp3"):
            yield from check_mp3(path)
        elif filename == "Folder.jpg":
            pass  # FIXME
        else:
            yield path, "Unexpected file"


def check_mp3(path_to_check):
    src = mutagen.id3.ID3(path_to_check, translate=False, load_v1=False)
    yield from check_from_wipe_mp3_junk_script(src, path_to_check)
    yield from check_track_numbering(src, path_to_check)
    yield from check_genre(src, path_to_check)
    if is_a_recent_file(path_to_check):
        yield from check_tagging_version(src, path_to_check)
        yield from check_year(src, path_to_check)
        yield from check_recent_stuff(src, path_to_check)


def check_from_wipe_mp3_junk_script(src, path_to_check):
    # See imemine/bin/wipe-mp3-junk for a script that cleans up the mp3
    # files but I keep forgetting exists.
    for prefix in ["TXXX", "TSSE", "TENC", "TDEN", "TLEN", "TBPM", "TFLT", "TPOS",
                   "TMED", "TCOP", "TPUB", "APIC", "PRIV", "MCDI", "COMM", "TCMP"]:
        for key in src:
            if key.startswith(prefix):
                yield path_to_check, "Contains key %r saying %r" % (key, src[key])


def check_track_numbering(src, path_to_check):
    if "TRCK" not in src:
        yield path_to_check, "Missing track number"
    else:
        if "/" not in src["TRCK"].text[0]:
            yield path_to_check, "Track number missing total number of tracks"


def check_genre(src, path_to_check):
    if "TCON" not in src:
        yield path_to_check, "Missing genre"
        return
    genre = src["TCON"].text[0]
    if genre == "":
        yield path_to_check, "Blank genre"
    if "unknown" in genre.lower():
        yield path_to_check, "Unknown genre"
    if ";" in genre:
        yield path_to_check, "Invalid multigenre"


def check_year(src, path_to_check):
    # FIXME also check TYER
    if "TDRL" in src and "TDRC" not in src:
        # While some programs (e.g. VLC on Android) will pick
        # up the year from other tags, MPD will only get it from
        # the ID3v2 TDRC tag.
        # Note that "eyeD3 -Y" sets TDRL whereas "abcde" sets TDRC
        yield path_to_check, "Year in wrong tag"


def check_tagging_version(src, path_to_check):
    if src.version < (2, 4):
        yield path_to_check, f"Still using ID3 version {src.version}"


def check_recent_stuff(src, path_to_check):
    if "TDTG" in src:
        yield path_to_check, "Unwanted tagging date"
    if "TCON" in src:
        genre = src["TCON"].text[0]
        if genre.startswith("("):
            if src.version >= (2, 4):
                yield path_to_check, "Old ID3 v2.3 genre"


def display(path, problem, dest):
    coloured = dest.isatty()
    parts = []
    if "/" in path:
        dir, base = path.rsplit("/", 1)
    else:
        dir, base = path, "n/a"  # FIXME
    if coloured:
        parts.append("\x1b[34;1m")
    parts.append("%s/" % dir)
    if coloured:
        parts.append("\x1b[0m")
        parts.append("\x1b[34m")
    parts.append("%s: " % base)
    if coloured:
        parts.append("\x1b[0m")
        parts.append("\x1b[31m")
    parts.append(problem[:200])
    if coloured:
        parts.append("\x1b[0m")
    parts.append("\n")
    dest.write("".join(parts))


def main():
    for path_to_check in sys.argv[1:]:
        for path, problem in check(path_to_check):
            display(path, problem, sys.stdout)


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        sys.stderr.write("[Interrupted]\n")
