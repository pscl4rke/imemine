#!/usr/bin/python2


import argparse
import datetime
import os
import subprocess
import sys
import time


def on_battery():
    output = subprocess.check_output(["upower", "--dump"])
    battery_line = [line.strip() for line in output.splitlines()
                    if "on-battery" in line][0]
    if "yes" in battery_line:
        return True
    if "no" in battery_line:
        return False
    raise Exception()


def parse_args(args):
    parser = argparse.ArgumentParser()
    parser.add_argument("source")
    parser.add_argument("title", type=int)
    parser.add_argument("destination", nargs='?', default=None)
    parser.add_argument("-u", "--ultrafast", action="store_true", default=False)
    parser.add_argument("-s", "--subtitle", action="store", type=int)
    return parser.parse_args(args)


class Ripper:

    def __init__(self, args):
        self.source = args.source
        self.title = args.title
        self.destination = args.destination
        self.verbose = True
        #self.chapters = "31-36"
        self.chapters = None
        self.subtitle_track = args.subtitle
        self.x264_preset = "ultrafast" if args.ultrafast else "veryslow"
        if self.destination is None:
            self.destination = self.guess_destination_path()

    def info(self, message):
        sys.stdout.write("%s\n" % message)
        sys.stdout.flush()

    def x264_options(self):
        return []

    def guess_destination_path(self):
        parts = []
        if self.source.endswith(".iso"):
            parts.append(self.source[:-4])
        else:
            raise Exception("Cannot guess destination for %r" % self.source)
        parts.append("title%02i" % self.title)
        if self.subtitle_track is not None:
            parts.append("sub%02i" % self.subtitle_track)
        parts.append(self.x264_preset)
        #parts.append("handrip")
        parts.append("mkv")
        return ".".join(parts)

    def ripping_arguments(self):
        args = ["nice", "HandBrakeCLI"]
        if self.verbose:
            args.append("--verbose")
        args.append("--decomb")
        args.extend(["--encoder", "x264"])
        args.extend(["--x264-preset", self.x264_preset])
        args.extend(["--encopts", ":".join(self.x264_options())])
        args.extend(["--vb", "685"])  # bitrate, kbps
        #args.extend(["--gain", "5"])  # audio, dB
        args.append("--markers")
        args.extend(["--input", self.source])
        args.extend(["--title", str(self.title)])
        ##args.extend(["--aname", "en"]) # This should work but doesn't!
        #args.extend(["--audio", "2"])
        #args.extend(["--native-language", "en"])
        #args.extend(["--native-language", "ja"])
        if self.subtitle_track is not None:
            args.extend(["--subtitle", str(self.subtitle_track)])
            args.extend(["--subtitle-burned"])
        #args.extend(["--audio", "3"])
        args.extend(["--output", self.destination])
        if self.chapters is not None:
            args.extend(["-c", self.chapters])
        return args

    def rip(self):
        assert self.destination.endswith(".mkv")
        assert not os.path.exists(self.destination)
        start = datetime.datetime.now()
        try:
            args = self.ripping_arguments()
            self.info("Running: %r" % args)
            subprocess.check_call(args)
        finally:
            end = datetime.datetime.now()
            time.sleep(1)
            self.info("Started:        %s" % start)
            self.info("Finished:       %s" % end)
            self.info("Total duration: %s" % (end - start))


if __name__ == '__main__':
    if on_battery():
        print "You're running on BATTERY!"
        print "I'm not continuing!"
        sys.exit(1)
    args = parse_args(sys.argv[1:])
    ripper = Ripper(args)
    ripper.rip()
