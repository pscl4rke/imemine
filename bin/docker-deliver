#!/usr/bin/python3
#======================================================================#
# DOCKER DIRECT DELIVERY TOOL                    (c) 2019 P. S. Clarke #
#======================================================================#


import os
import shutil
import subprocess
import sys
import tempfile


class pushd:
    def __init__(self, path):
        self.path = path
    def __enter__(self):
        self.original = os.getcwd()
        os.chdir(self.path)
    def __exit__(self, *errs):
        os.chdir(self.original)


class DirectoryDestination:

    def __init__(self, path):
        self.path = os.path.realpath(path)
        os.mkdir(self.path)

    def needed(self, image_id):
        return True

    def deliver(self, srcpath, filenamemade):
        filepathmade = os.path.realpath(os.path.join(self.path, filenamemade))
        shutil.copy(srcpath, filepathmade)
        return filenamemade


class SshDestination:

    def __init__(self, host):
        self.host = host
        self._ping()

    def _ping(self):
        #output = self.check_output(["ssh", self.host, "echo pong"])
        #if output != "pong":
        #    raise Exception("No connection to %r" % self.host)
        subprocess.check_call(["ssh", "-o", "BatchMode=yes", self.host, "docker images"], stdout=subprocess.DEVNULL)

    def needed(self, image_id):
        cmd = "docker image inspect %s" % image_id
        try:
            subprocess.check_call(["ssh", self.host, cmd], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            return False
        except subprocess.CalledProcessError:
            return True

    def deliver(self, srcpath, filenamemade):
        with open(srcpath, "rb") as srcfile:
            subprocess.check_call(["ssh", self.host, "docker load"], stdin=srcfile)
            return "Loaded in"


def get_destination_from(destination_id):
    if "/" in destination_id:
        return DirectoryDestination(destination_id)
    else:
        return SshDestination(destination_id)
        #raise Exception("Unknown destination type: %r" % destination_id)


class Exporter:

    def get_image_names(self):
        # actually the final one should be the top name rather
        # than image id so the name and version num get imported
        images = {}
        text = subprocess.check_output(["docker", "images"])
        for line in text.decode().splitlines():
            columns = line.strip().split()
            name, version, image = columns[0:3]
            images[image] = "%s:%s" % (name, version)
        return images

    def export(self, topname, destination):
        layers_exported = []
        image_names = self.get_image_names()
        #print("%i local images" % len(image_names))
        for i_minus, image in enumerate(self.images_to_export(topname)):
            print(image, " ", end="")
            sys.stdout.flush()
            if not destination.needed(image):
                print("(not needed)")
                continue
            name = image_names.get(image, "N:N").split(":")[0]
            filenamemade = "%02i.%s.%s.tar" % ((i_minus + 1), image, name)
            identifier = image_names.get(image, image)
            with tempfile.NamedTemporaryFile() as f:
                self.export_except(identifier, layers_exported, f.name)
                layers_exported.extend(self.layers_in(f.name))
                result = destination.deliver(f.name, filenamemade)
            print(result)

    def images_to_export(self, topname):
        images = []
        text = subprocess.check_output(["docker", "image", "history", topname])
        for line in text.decode().splitlines():
            columns = line.strip().split()
            image = columns[0]
            if image == "IMAGE":  # header
                continue
            if image == "<missing>":
                continue
            images.append(image)
        images.reverse()
        return images

    def export_except(self, identifier, layers_exported, outputpath):
        with tempfile.TemporaryDirectory() as tempdirpath:
            with pushd(tempdirpath):
                tar = subprocess.Popen(["tar", "x"], stdin=subprocess.PIPE)
                subprocess.check_call(["docker", "image", "save", identifier], stdout=tar.stdin)
                tar.stdin.close()
                if tar.wait() != 0:
                    raise Exception()
                contents = [entry for entry in os.listdir(".")
                            if os.path.isfile(entry)
                            or entry not in layers_exported]
                subprocess.check_call(["tar", "c", "--numeric-owner", "--owner=0", "--group=0", "-f", outputpath, *contents])

    def layers_in(self, filepath):
        layers = []
        text = subprocess.check_output(["tar", "tf", filepath])
        for line in text.decode().splitlines():
            line = line.strip()
            if line.endswith("/layer.tar"):
                layers.append(line.split("/")[0])
        return layers


def main():
    destination = get_destination_from(sys.argv[2])
    Exporter().export(sys.argv[1], destination)


if __name__ == '__main__':
    main()
